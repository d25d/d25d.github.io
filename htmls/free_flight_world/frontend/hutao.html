<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>核心展示</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0a1a, #1a1a3a);
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        button {
            background: #3a5a78;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #4a7a98;
        }
    </style>
</head>
<body>
    <!-- <iframe frameborder="0" src="https://3dview.laozicloud.com/inset/general?id=ccf5c39082b94b78a4405b6f52b7b232"></iframe> -->
    <div id="loading">加载机甲模型中...</div>
    <div id="container"></div>
    <!-- 模型选择和加载状态区域 -->
    <div style="position: fixed; top: 20px; left: 20px; z-index: 1000; color: white;">
        <div style="position: fixed; top: 20px; left: 20px; z-index: 1000; color: white;">
        <div id="fileButtonsContainer" style="
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: nowrap; /* 关键：禁用换行，强制横向排列 */
            overflow-x: auto; /* 关键：横向溢出时显示滚动条 */
            overflow-y: hidden; /* 隐藏纵向滚动条 */
            padding: 10px 0; /* 上下内边距，优化视觉 */
            height: 5vh; /* 固定容器高度（根据按钮大小调整） */
            align-items: center; /* 按钮垂直居中 */
            border: 1px solid #eee; /* 可选：添加边框，突出长条容器 */
            border-radius: 8px; /* 可选：圆角优化 */
            background: #fafafa; /* 可选：背景色，区分其他区域 */
        "></div>
    <label for="modelFile" style="font-size: 16px; margin-right: 10px;">选择本地.glb模型：</label>
    <input type="file" id="modelFile" accept=".glb" style="display: inline-block; padding: 5px; background: #333; color: white; border: none; border-radius: 4px;">
    <div id="loadStatus" style="margin-top: 10px; font-size: 14px;">未选择文件</div>
    </div>
    <!-- <div id="controls">
        <button id="rotateHead">旋转头部</button>
        <button id="rotateArms">旋转手臂</button>
        <button id="reset">重置姿势</button>
    </div> -->

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script>
        // 根据当前页面位置动态设置base
        //const basePath = window.location.pathname.includes('/htmls/') ? '../../../' : './';
       // document.write(`<base href="${basePath}">`);    
    </script>
    <script type="module">
        import { GLTFLoader } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/GLTFLoader";
        import { Sky } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/objects/Sky.js";
        //import glbData from '../../../3ds.json';

        // 关键：3ds 文件夹的相对路径（相对于当前 index.html 的路径，需按实际调整！）
        // 示例：如果 index.html 在「前端项目根目录/dist/html」，3ds 在「前端项目根目录/3ds」，则路径为 '../../../3ds'
         
        
        const GLB_FOLDER_PATH = '../../../3ds';

        // 页面加载后自动扫描 3ds 文件夹
        window.onload = async () => {
        try {
            // statusEl.textContent = '正在扫描 3ds 文件夹...';
            
            // 步骤1：请求 3ds 文件夹目录（需服务器/HTTP 服务支持目录列表响应）
            // 核心原理：HTTP 服务访问文件夹路径时，会返回目录下的文件列表（如 Nginx 默认开启，Live Server 也支持）
            // const response = await fetch(GLB_FOLDER_PATH);
            
            // if (!response.ok) {
            // throw new Error(`文件夹访问失败（状态码：${response.status}）`);
            // }
            
            // 步骤2：解析目录响应（不同 HTTP 服务的目录页面结构不同，以下适配 Live Server/Nginx 默认格式）
            // const html = await response.text();
            // const glbFileNames = parseDirectoryHtml(html); // 提取 .glb 文件名
            
            // 改用 await 等待 fetch 结果，避免异步错乱
            const res = await fetch('../../../3ds.json');
            const data = await res.json();
            const glbFileNames = data.models || []; // 兜底空数组，防止 undefined
            console.log(glbFileNames);
            
            if (glbFileNames.length === 0) {
            // statusEl.textContent = '3ds 文件夹中未找到 .glb 文件';
            return;
            }
            
            // statusEl.textContent = `成功扫描到 ${glbFileNames.length} 个 .glb 文件`;
            
            // 步骤3：生成每个 .glb 文件对应的按钮
            glbFileNames.forEach((fileName) => {
            const btn = document.createElement('button');
            btn.textContent = fileName;
            btn.style.padding = '8px 8px';
            btn.style.cursor = 'pointer';
            btn.style.background = '#2196F3';
            btn.style.color = 'white';
            btn.style.border = 'none';
            btn.style.borderRadius = '4px';
            btn.style.transition = 'background 0.2s';
            
            btn.addEventListener('mouseover', () => btn.style.background = '#1976D2');
            btn.addEventListener('mouseout', () => btn.style.background = '#2196F3');
            
            // 步骤4：按钮点击事件 - 自动选中对应 .glb 文件
            btn.addEventListener('click', async () => {
                try {
                // 构建 .glb 文件的完整路径（相对路径拼接）
                const fileFullPath = `${GLB_FOLDER_PATH}/${fileName}`;
                
                // 关键：通过 fetch 获取文件 blob，再模拟文件选择器选中
                const fileResponse = await fetch(fileFullPath);
                const fileBlob = await fileResponse.blob();
                
                // 构建 File 对象（文件名 + blob 数据 + MIME 类型）
                const glbFile = new File([fileBlob], fileName, { type: 'model/gltf-binary' });
                
                // 模拟文件选择器选中文件（DataTransfer API）
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(glbFile);
                modelFileInput.files = dataTransfer.files;
                
                // 触发文件选择器的 change 事件（若后续有依赖该事件的逻辑）
                modelFileInput.dispatchEvent(new Event('change'));
                
                // statusEl.textContent = `已自动选中文件：${fileName}`;
                } catch (error) {
                // statusEl.textContent = `选中文件失败：${error.message}`;
                console.error('文件选中失败：', error);
                }
            });
            
            fileButtonsContainer.appendChild(btn);
            });
        } catch (error) {
            // statusEl.textContent = `扫描失败：${error.message}`;
            console.error('文件夹扫描失败：', error);
        }
        };

        /**
         * 解析 HTTP 服务返回的目录 HTML，提取所有 .glb 文件名
         * 适配 Live Server、Nginx 默认的目录页面结构（可根据实际 HTTP 服务调整）
         */
        function parseDirectoryHtml(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const fileNames = [];
        
        // 查找所有 <a> 标签（目录页面中文件通常以链接形式展示）
        const links = doc.querySelectorAll('a');
        links.forEach((link) => {
            const href = link.getAttribute('href');
            // 筛选 .glb 后缀的文件，且排除目录（href 以 / 结尾的是子目录）
            if (href && href.endsWith('.glb') && !href.endsWith('/')) {
            // 提取文件名（href 可能是相对路径，取最后一段）
            const fileName = href.split('/').pop();
            if (fileName) fileNames.push(fileName);
            }
        });
        
        // 去重（避免重复文件）
        return [...new Set(fileNames)];
        }
        
        function getObjectRealHeight(object) {
            // 1. 创建包围盒（用于包裹物体所有顶点）
            const boundingBox = new THREE.Box3();

            // 2. 计算物体的包围盒（关键：递归包含所有子物体）
            if (object.isMesh) {
                boundingBox.setFromObject(object);
            } else {
                object.traverse((child) => {
                    if (child.isMesh) {
                        boundingBox.expandByObject(child);
                    }
                });
            }

            // ---------------- 核心添加：包围盒红色线框可视化 ----------------
            // 先移除物体上已存在的线框（避免重复创建，导致线框堆积）
            if (object.userData.boundingBoxHelper) {
                object.remove(object.userData.boundingBoxHelper);
            }

            // 创建红色线框辅助器（Box3Helper：基于包围盒生成线框）
            const boxHelper = new THREE.Box3Helper(
                boundingBox,        // 绑定计算出的包围盒
                0xff0000            // 线框颜色：红色（#ff0000）
            );
            boxHelper.linewidth = 2; // 线框宽度（2px，清晰可见）

            // 存储线框到物体的 userData 中（方便后续移除）
            object.userData.boundingBoxHelper = boxHelper;
            // 将线框添加到物体上（跟随物体移动、旋转，不会错位）
            object.add(boxHelper);
            // ----------------------------------------------------------------

            // 3. 计算包围盒的尺寸
            const size = new THREE.Vector3();
            boundingBox.getSize(size);

            // 4. 考虑世界缩放
            const worldScale = new THREE.Vector3();
            object.getWorldScale(worldScale);
            const realHeight = size.y * worldScale.y;

            // 打印关键信息（辅助调试：对比线框和日志）
            // console.log("计算的包围盒范围：");
            // console.log("底部 Y 坐标：", boundingBox.min.y);
            // console.log("顶部 Y 坐标：", boundingBox.max.y);
            // console.log("计算高度：", realHeight);

            return realHeight;
        }
        // -------------- 参考刻度柱生成函数（可直接复制使用）--------------
        function createHeightReferencePole() {
            // 1. 创建刻度柱的父容器（方便统一管理，后续可整体移动/隐藏）
            const poleGroup = new THREE.Group();
            poleGroup.position.set(0, 0, 0); // 刻度柱放在 X=-5 位置（避免和模型重叠，可按需调整）

            // 2. 创建主柱子（高度10，半径0.1，白色半透明）
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 10, 32); // 圆柱：上底半径、下底半径、高度、分段数
            const poleMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.7 // 半透明，不遮挡模型
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            // 圆柱默认中心点在中间（Y=5），调整锚点到底部（Y=0）
            pole.position.y = 5; 
            poleGroup.add(pole);

            // 3. 添加刻度标记（每1单位一个红色小球）和数字标签
            for (let height = 1; height <= 10; height++) {
                // 3.1 红色标记点（半径0.15，比柱子粗，显眼）
                const markerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // 红色不透明，醒目
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(0, height, 0); // 标记点在当前高度的 Y 轴位置
                poleGroup.add(marker);

                // 3.2 数字标签（显示当前高度，如 "1"、"2"...）
                // 创建 canvas 作为标签纹理（Three.js 中文字需通过 canvas 实现）
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;

                // 设置文字样式（白色字体，黑色背景，居中显示）
                ctx.fillStyle = '#000000'; // 黑色背景
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff'; // 白色文字
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(height.toString(), canvas.width / 2, canvas.height / 2);

                // 将 canvas 转为 Three.js 纹理
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                const labelSprite = new THREE.Sprite(labelMaterial);

                // 调整标签大小和位置（在标记点右侧 0.5 单位，避免遮挡）
                labelSprite.scale.set(1, 0.5, 1); // 标签大小（宽1，高0.5）
                labelSprite.position.set(0.8, height, 0); // 在标记点右侧 0.8 单位
                poleGroup.add(labelSprite);
            }

            return poleGroup;
        }

        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();

        // 创建坐标轴辅助器（参数：坐标轴长度，默认 1，可按需调整）
        const axesHelper = new THREE.AxesHelper(1); // 这里设为 5，数值越大坐标轴越长
        scene.add(axesHelper); // 将坐标轴添加到场景

        scene.background = new THREE.Color(0x0a0a1a);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 8);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        document.getElementById('container').appendChild(renderer.domElement);
        const modelFileInput = document.getElementById('modelFile'); // 文件选择器

        // 添加高度参考刻度柱
        const heightPole = createHeightReferencePole();
        scene.add(heightPole); // 添加到场景中
        
        // 添加光源
        // 1. 环境光：均匀照亮所有物体，无阴影，主要用于提亮整体
        const ambientLight = new THREE.AmbientLight(0xffffff, 1); // 颜色：白色，强度：0.6（0~1 可调）
        scene.add(ambientLight);

        // 2. 平行光：模拟太阳光，有方向性，能产生阴影（让物体更立体）
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // 颜色：白色，强度：0.8
        directionalLight.position.set(5, 10, 7); // 光源位置（调整方向，避免直射或过暗）
        scene.add(directionalLight);

        // 3. 新增补光（解决阴影处过暗）
        const fillLight = new THREE.DirectionalLight(0xffffdd, 0.9); // 暖白色补光
        fillLight.position.set(-8, 10, -5); // 与主光源反向
        scene.add(fillLight);

        // （可选）开启阴影投射（让物体产生真实阴影，更有质感）
        directionalLight.castShadow = true;
        // 优化阴影质量（可选，根据性能调整）
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;

        //控制系统和相机的绑定
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        let targetOffset=null;
        
        
       
        const sky = new Sky();
        sky.scale.setScalar(400); // 根据需要调整天空的大小
        scene.add(sky);
        const uniforms = sky.material.uniforms;
        uniforms['turbidity'].value = 10;
        uniforms['rayleigh'].value = 3;
        uniforms['mieCoefficient'].value = 0.1;
        uniforms['mieDirectionalG'].value = 0.95;
        uniforms['sunPosition'].value.set(0.3, -0.038, -0.95);
        uniforms['sunPosition'].value.set(0, 0, 0);
        // 根据需要调整太阳的位置
        const sun1 = new THREE.Vector3();
        const phi = THREE.MathUtils.degToRad(88);
        const theta = THREE.MathUtils.degToRad(180);
        sun1.setFromSphericalCoords(1, phi, theta);
        uniforms.sunPosition.value.copy(sun1);

        // 1. 创建太阳球体（可视化，带自发光）
        const sunGeometry = new THREE.SphereGeometry(1, 32, 32); // 半径1，分段数32
        const sunMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00, // 太阳黄色
        emissive: 0xffff00, // 自发光颜色
        emissiveIntensity: 50 // 发光强度（数值越大越亮）
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(50, 30, 20); // 放在场景远处（避免遮挡模型）
        scene.add(sun);
        

        // 2. 绑定强平行光（太阳光源，照亮整个场景）
        const sunLight = new THREE.DirectionalLight(0xffffff, 5.0); // 强光强度2.0
        sunLight.position.copy(sun.position); // 光源位置和太阳球体一致
        scene.add(sunLight);

        // 3. 可选：添加太阳光晕（更真实）
        const glowGeometry = new THREE.SphereGeometry(1.1, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffdd,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending // 叠加混合，光晕效果
        });
        const sunGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        sun.add(sunGlow); // 光晕跟随太阳


        // 1. 创建地板（保留原有配置）
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshLambertMaterial({
        color: 0xC39178,
        transparent: true,
        opacity: 0.8
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        scene.add(floor);

        // 2. 添加网格线（关键新增）
        const gridSize = 200; // 网格大小和地板一致
        const gridDivisions = 40; // 分割数（40=200/5，每格5单位）
        const gridHelper = new THREE.GridHelper(
        gridSize,
        gridDivisions,
        0xffffff, // 网格线颜色（白色，醒目）
        0x444444  // 辅助线颜色（深灰色，不杂乱）
        );
        gridHelper.position.y = 0.001; // 略高于地板，避免遮挡
        scene.add(gridHelper);
        


        // const mache = new THREE.Object3D();
        let mache = new THREE.Group();
        let loader = new GLTFLoader();


        // loader.load(
        // "../../../3ds/hutao.glb", // 替换为您的 GLB 文件路径
        // //    "girl/woman.gltf", 
        // function(gltf){
            
        //     mache.add(gltf.scene);

        //     // 检查模型是否为 THREE.Object3D 的实例
        //     if (!(mache instanceof THREE.Object3D)) {
        //         console.error('加载的 GLB 模型不是 THREE.Object3D 的实例');
        //         return;
        //     }

        //     // 调整模型的大小和位置
        //     mache.scale.set(1, 1, 1); // 根据需要调整缩放比例
        //     mache.position.set(2, 0, 0); // 根据需要调整位置
        //     //player.mesh=mache;
        //     // 将模型添加到场景中
        //     scene.add(mache);
        //     document.getElementById('loading').style.display = 'none';

        //     // 相机控制
        //     // let targetOffset=  new THREE.Vector3(0, getObjectRealHeight(mache)/2, 0);
        //     controls.target = mache.position.clone().add(new THREE.Vector3(0,1.2,0)); // 控制器旋转中心设为物体（跟随物体移动）
        //     console.log("模型高度：",getObjectRealHeight(mache),"相机从脚底偏移量高度：", targetOffset,mache.position.x,mache.position.y,mache.position.z);

        // });


        // ------------ 核心：文件选择和加载逻辑 ------------
        modelFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; // 获取选择的文件
            if (!file) return;

            // 1. 格式校验（只允许 gltf 和 glb）
            const fileExt = file.name.split('.').pop().toLowerCase();
            if (!['gltf', 'glb'].includes(fileExt)) {
                loadStatus.style.color = '#ff4444';
                loadStatus.textContent = `错误：仅支持.glb 格式，当前文件格式为 .${fileExt}`;
                return;
            }

            // 2. 重置状态，显示加载中
            loadStatus.style.color = '#ffff00';
            loadStatus.textContent = `加载中：0%`;

            // 3. 清空原有模型（如果有）
            if (mache.children.length > 0) {
                mache.remove(...mache.children); // 移除旧模型
                // 移除旧模型的包围盒线框
                if (mache.userData.boundingBoxHelper) {
                mache.remove(mache.userData.boundingBoxHelper);
                mache.userData.boundingBoxHelper = null;
                }
            }

            // 4. 加载本地文件（通过 FileReader 读取文件内容）
            const reader = new FileReader();
            reader.onload = function(loadEvent) {
                const content = loadEvent.target.result; // 文件内容（ArrayBuffer 或 DataURL）

                // 5. 用 GLTFLoader 加载文件内容
                loader.load(
                // 本地文件用 Blob URL 或 ArrayBuffer 加载
                URL.createObjectURL(file), // 生成临时 Blob URL（推荐，支持大文件）
                // 加载成功回调
                function(gltf) {
                    // 添加新模型到父容器
                    mache.add(gltf.scene);
                    mache.scale.set(1, 1, 1); // 重置缩放
                    mache.position.set(2, 0, 0); // 先设目标X/Z位置（脚底最终X/Z=2,0）

                    // 计算原始包围盒（未偏移、未缩放状态）
                    let box = new THREE.Box3().setFromObject(mache);
                    let size = new THREE.Vector3();
                    box.getSize(size);
                    let center = new THREE.Vector3();
                    box.getCenter(center);

                    // 1. 计算缩放系数：强制模型最终高度=10
                    let scale = 10 / size.y; // 按原始高度算，确保缩放后高度=10
                    mache.scale.set(scale, scale, scale); // 先缩放

                    // 2. 重新计算缩放后的包围盒，获取真实底部偏移
                    box = new THREE.Box3().setFromObject(mache);
                    box.getSize(size); // 缩放后尺寸（height=10）
                    box.getCenter(center); // 缩放后中心点

                    // 3. 计算Y偏移：让脚底贴y=0
                    let yOffset = -(center.y - size.y / 2);
                    mache.position.y += yOffset; // 叠加偏移（不覆盖原有Y=0）

                    console.log("最终模型高度：", size.y, "脚底位置：", mache.position);

                    // 确保模型添加到场景
                    if (!scene.children.includes(mache)) {
                    scene.add(mache);
                    document.getElementById('loading').style.display = 'none';
                    }

                    // 6. 延迟校准锚点和计算高度（确保模型初始化完成）
                    setTimeout(() => {
                    // 校准锚点到脚底（排除下方空空间）
                    // const originalBottomY = getModelBottomY(mache);
                    // mache.position.y -= originalBottomY;

                    // 计算真实高度（带红色线框可视化）
                    let size1 = new THREE.Vector3();
                    new THREE.Box3().setFromObject(mache).getSize(size1);
                    const realHeight = size1.y;

                    // const realHeight = getObjectRealHeight(mache);

                    // 7. 初始化/更新相机控制器
                    if (!controls) {
                        controls = new THREE.OrbitControls(camera, renderer.domElement);
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.25;
                    }
                    // 更新旋转中心到模型中心
                    const targetOffset = new THREE.Vector3(0, realHeight*0.75, 0);
                    controls.target = mache.position.clone().add(targetOffset).add(new THREE.Vector3(0, -yOffset, 0));

                    // 加载成功提示
                    loadStatus.style.color = '#00ff00';
                    loadStatus.textContent = `加载成功！模型高度：${realHeight.toFixed(2)} 单位`;
                    }, 150);
                },
                // 加载进度回调
                function(xhr) {
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                    loadStatus.textContent = `加载中：${percent}%`;
                },
                // 加载失败回调
                function(error) {
                    loadStatus.style.color = '#ff4444';
                    loadStatus.textContent = `加载失败：${error.message.slice(0, 50)}...`;
                    console.error('模型加载失败：', error);
                }
                );
            };

            // 读取文件（GLTF/GLB 用 ArrayBuffer 格式读取，兼容性更好）
            reader.readAsArrayBuffer(file);
        });
    

        
        
        
        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);
        
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
