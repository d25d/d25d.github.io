<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>核心展示</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0a1a, #1a1a3a);
            font-family: Arial, sans-serif;
            user-select: none;;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        /* canvas 强制占满容器 */
        #container canvas {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover; /* 防止拉伸，保持比例 */
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 100;
        }
        button {
            background: #3a5a78;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #4a7a98;
        }
        /* 摇杆容器样式（固定在左下角） */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            z-index: 10000;
        }
        

        /* 适配移动端竖屏：屏幕高度 > 宽度时触发 */
        @media screen and (orientation: portrait) {
            body {
                width: 100vh; /* 宽度设为屏幕高度（旋转后占满屏幕） */
                height: 100vw; /* 高度设为屏幕宽度 */
                transform: rotate(90deg) translateY(-100%); /* 顺时针旋转90度 */
                transform-origin: top left; /* 旋转中心点：左下角（避免偏移） */
                overflow: hidden; /* 隐藏溢出内容 */
                position: fixed; /* 固定定位，防止滚动 */
            }
            #joystick-container {
                width: 120px; /* 宽度设为屏幕高度（旋转后占满屏幕） */
                height: 120px; /* 高度设为屏幕宽度 */
                transform: rotate(-90deg) translateY(0%); /* 逆时针旋转90度 */
                bottom: -30%;
                transform-origin: top left; /* 旋转中心点：左下角（避免偏移） */
            }
        }

        /* 横屏时恢复默认（可选，确保PC端正常） */
        @media screen and (orientation: landscape) {
            body {
                transform: none;
                width: 100vw;
                height: 100vh;
                position: static;
            }
            #joystick-container {
                transform: none;
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- <iframe frameborder="0" src="https://3dview.laozicloud.com/inset/general?id=ccf5c39082b94b78a4405b6f52b7b232"></iframe> -->
    <div id="loading">请选择模型...</div>
    <div id="container"></div>
    <!-- 模型选择和加载状态区域 -->
    <button id="button1"  style="position: fixed; top: 20px; left: 20px; z-index: 1000;" onclick="
        this.style.display='none'; // 隐藏自身
        document.getElementById('menu').style.display='block'; // 显示menu
   ">选择模型</button>
    <div id="menu" style="display : none; position: fixed; top: 20px; left: 20px; z-index: 1000; color: white;">
        <button style="position: fixed; top: 20px; left: 20px; z-index: 1000;" onclick="
            document.getElementById('button1').style.display='block';
            document.getElementById('menu').style.display='none';
            ">收起</button>
        <div style="position: fixed; top: 40px; left: 20px; z-index: 1000; color: white;">
            <div id="fileButtonsContainer" style="
                margin: 20px 0;
                display: flex;
                gap: 10px;
                flex-wrap: nowrap; /* 关键：禁用换行，强制横向排列 */
                overflow-x: auto; /* 关键：横向溢出时显示滚动条 */
                overflow-y: hidden; /* 隐藏纵向滚动条 */
                padding: 10px 0; /* 上下内边距，优化视觉 */
                height: 5vh; /* 固定容器高度（根据按钮大小调整） */
                align-items: center; /* 按钮垂直居中 */
                border: 1px solid #eee; /* 可选：添加边框，突出长条容器 */
                border-radius: 8px; /* 可选：圆角优化 */
                background: #fafafa; /* 可选：背景色，区分其他区域 */
            "></div>
            <label for="modelFile" style="font-size: 16px; margin-right: 10px;">选择本地.glb模型：</label>
            <input type="file" id="modelFile" accept=".glb" style="display: inline-block; padding: 5px; background: #333; color: white; border: none; border-radius: 4px;">
            <div id="loadStatus" style="margin-top: 10px; font-size: 14px;">未选择文件</div>
        </div>
    </div>
    <div id="joystick-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.0/dist/nipplejs.min.js"></script>  

    <script type="module">
        import { GLTFLoader } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/GLTFLoader";
        import { Sky } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/objects/Sky.js";
        //import glbData from '../../../3ds.json';

        // 关键：3ds 文件夹的相对路径（相对于当前 index.html 的路径，需按实际调整！）
        // 示例：如果 index.html 在「前端项目根目录/dist/html」，3ds 在「前端项目根目录/3ds」，则路径为 '../../../3ds'
         
        
        const GLB_FOLDER_PATH = '../../../3ds';
        // -------------------------- 核心新增：键盘控制变量 --------------------------
        const keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };
        const moveSpeed = 8; // 移动速度（单位/秒）
        let lastTime = performance.now(); // 用于计算帧率时间差
        let isModelLoaded = false; // 标记模型是否加载完成（避免未加载时触发移动）

        let joystickMoveVec = new THREE.Vector3(); // 摇杆移动方向向量

        // --------------------------------------------------------------------------
        // -------------------------- 核心新增：键盘事件监听 --------------------------
        document.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = true; // 按键按下时设为 true
        });
        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = false; // 按键松开时设为 false
        });

        // 初始化摇杆
        const joystick = nipplejs.create({
            zone: document.getElementById('joystick-container'), // 绑定容器
            mode: 'static', // 固定位置
            position: { left: '50%', top: '50%' }, // 居中
            color: 'white', // 白色摇杆（适配深色背景）
            size: 120, // 大小匹配容器
            threshold: 0.1, // 避免轻微触摸误触发
            fadeTime: 200 // 松开后平滑淡出
        });

        // 摇杆移动时：更新移动方向
        joystick.on('move', (evt, data) => {
            const angle = data.angle.radian; // 摇杆角度
            const force = Math.min(data.force, 1); // 按压力度（0~1）
            let isPortrait = screen.orientation.type.includes('portrait');
            if (isPortrait) {
                //代表已经顺时针90度
                joystickMoveVec.x = -Math.sin(angle) * force; // 左右方向
                joystickMoveVec.z = -Math.cos(angle) * force; // 前后方向（向上=向前）   
            }
            else{
                joystickMoveVec.z = -Math.sin(angle) * force; // 左右方向
                joystickMoveVec.x = Math.cos(angle) * force; // 前后方向（向上=向前）
            }
            
        });

        // 松开摇杆：停止移动
        joystick.on('end', () => {
            joystickMoveVec.set(0, 0, 0);
        });
        // --------------------------------------------------------------------------
        // -------------------------- 核心新增：模型移动逻辑 --------------------------
        function moveModel(deltaTime) {
            if (!isModelLoaded) return; // 模型未加载时直接返回，不执行移动
            
            const moveVec = new THREE.Vector3(); // 存储移动方向的向量（x=左右，z=前后）
            
            // 1. 根据按键/摇杆状态设置「本地移动方向」（相对相机的方向）
            if (keys.w || keys.ArrowUp) moveVec.z = -1; // 相对相机向前（z轴负方向）
            if (keys.s || keys.ArrowDown) moveVec.z = 1; // 相对相机向后（z轴正方向）
            if (keys.a || keys.ArrowLeft) moveVec.x = -1; // 相对相机向左（x轴负方向）
            if (keys.d || keys.ArrowRight) moveVec.x = 1; // 相对相机向右（x轴正方向）

            // 键盘控制优先，摇杆次之（避免冲突）
            if (moveVec.length() === 0) {
                moveVec.copy(joystickMoveVec);
            }
            
            // 2. 归一化方向向量：避免斜向移动时速度变快
            if (moveVec.length() > 0) moveVec.normalize();
            
            // -------------------------- 核心修改：将移动向量转换为相机朝向 --------------------------
            // 创建相机的「局部坐标系」（仅考虑 XZ 平面旋转，忽略 Y 轴高度）
            const cameraQuaternion = new THREE.Quaternion();
            camera.getWorldQuaternion(cameraQuaternion); // 获取相机的旋转四元数
            cameraQuaternion.x = 0; // 锁定 X 轴旋转（避免相机抬头/低头影响移动方向）
            cameraQuaternion.z = 0; // 锁定 Z 轴旋转（避免相机倾斜影响移动方向）
            cameraQuaternion.normalize(); // 归一化四元数，确保旋转有效
            
            // 将「相对相机的移动向量」应用相机旋转，转换为「世界坐标系的移动向量」
            moveVec.applyQuaternion(cameraQuaternion);
            // ----------------------------------------------------------------------------------------
            moveVec.normalize();
            // -------------------------- 核心新增：模型朝向移动方向 --------------------------
            if (moveVec.length() > 0) { // 有移动时才转向
                mache.lookAt(mache.position.clone().add(moveVec)); // 模型看向移动方向
                //mache.lookAt(new THREE.Vector3(0,0,0));
                // mache.rotation.x = 0; // 锁定X轴旋转（避免模型倾斜）
                // mache.rotation.z = 0; // 锁定Z轴旋转（避免模型侧翻
            }
            // --------------------------------------------------------------------------------

            // 3. 更新模型位置：使用转换后的世界坐标系向量
            mache.position.addScaledVector(moveVec, moveSpeed * deltaTime);
            
            // 4. 相机跟随模型（保持相对位置，基于转换后的移动向量）
            camera.position.addScaledVector(moveVec, moveSpeed * deltaTime);

            // 计算模型高度和中心，更新相机控制器目标
            let size1 = new THREE.Vector3();
            new THREE.Box3().setFromObject(mache).getSize(size1);
            let realHeight = size1.y;

            let center = new THREE.Vector3();
            new THREE.Box3().setFromObject(mache).getCenter(center);
            let yOffset = -(center.y - size1.y / 2);

            // 更新旋转中心到模型中心
            let targetOffset = new THREE.Vector3(0, realHeight*0.75, 0);
            controls.target = mache.position.clone().add(targetOffset).add(new THREE.Vector3(0, -yOffset, 0));

        }
        // --------------------------------------------------------------------------

        

        // 页面加载后自动扫描 3ds 文件夹
        window.onload = async () => {
        try {    
            // 改用 await 等待 fetch 结果，避免异步错乱
            const res = await fetch('../../../3ds.json');
            const data = await res.json();
            const glbFileNames = data.models || []; // 兜底空数组，防止 undefined
            //console.log(glbFileNames);
            
            if (glbFileNames.length === 0) {
            // statusEl.textContent = '3ds 文件夹中未找到 .glb 文件';
            return;
            }
            
            // statusEl.textContent = `成功扫描到 ${glbFileNames.length} 个 .glb 文件`;
            
            // 步骤3：生成每个 .glb 文件对应的按钮
            glbFileNames.forEach((fileName) => {
            const btn = document.createElement('button');
            btn.textContent = fileName;
            btn.style.padding = '8px 8px';
            btn.style.cursor = 'pointer';
            btn.style.background = '#2196F3';
            btn.style.color = 'white';
            btn.style.border = 'none';
            btn.style.borderRadius = '4px';
            btn.style.transition = 'background 0.2s';
            
            btn.addEventListener('mouseover', () => btn.style.background = '#1976D2');
            btn.addEventListener('mouseout', () => btn.style.background = '#2196F3');
            
            // 步骤4：按钮点击事件 - 自动选中对应 .glb 文件
            btn.addEventListener('click', async () => {
                try {
                // 构建 .glb 文件的完整路径（相对路径拼接）
                const fileFullPath = `${GLB_FOLDER_PATH}/${fileName}`;
                
                // 关键：通过 fetch 获取文件 blob，再模拟文件选择器选中
                const fileResponse = await fetch(fileFullPath);
                const fileBlob = await fileResponse.blob();
                
                // 构建 File 对象（文件名 + blob 数据 + MIME 类型）
                const glbFile = new File([fileBlob], fileName, { type: 'model/gltf-binary' });
                
                // 模拟文件选择器选中文件（DataTransfer API）
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(glbFile);
                modelFileInput.files = dataTransfer.files;
                
                // 触发文件选择器的 change 事件（若后续有依赖该事件的逻辑）
                modelFileInput.dispatchEvent(new Event('change'));
                
                // statusEl.textContent = `已自动选中文件：${fileName}`;
                } catch (error) {
                // statusEl.textContent = `选中文件失败：${error.message}`;
                console.error('文件选中失败：', error);
                }
            });
            
            fileButtonsContainer.appendChild(btn);
            });
        } catch (error) {
            // statusEl.textContent = `扫描失败：${error.message}`;
            console.error('文件夹扫描失败：', error);
        }
        };
        
        // -------------- 参考刻度柱生成函数（可直接复制使用）--------------
        function createHeightReferencePole() {
            // 1. 创建刻度柱的父容器（方便统一管理，后续可整体移动/隐藏）
            const poleGroup = new THREE.Group();
            poleGroup.position.set(0, 0, 0); // 刻度柱放在 X=-5 位置（避免和模型重叠，可按需调整）

            // 2. 创建主柱子（高度10，半径0.1，白色半透明）
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 10, 32); // 圆柱：上底半径、下底半径、高度、分段数
            const poleMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.7 // 半透明，不遮挡模型
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            // 圆柱默认中心点在中间（Y=5），调整锚点到底部（Y=0）
            pole.position.y = 5; 
            poleGroup.add(pole);

            // 3. 添加刻度标记（每1单位一个红色小球）和数字标签
            for (let height = 1; height <= 10; height++) {
                // 3.1 红色标记点（半径0.15，比柱子粗，显眼）
                const markerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // 红色不透明，醒目
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(0, height, 0); // 标记点在当前高度的 Y 轴位置
                poleGroup.add(marker);

                // 3.2 数字标签（显示当前高度，如 "1"、"2"...）
                // 创建 canvas 作为标签纹理（Three.js 中文字需通过 canvas 实现）
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;

                // 设置文字样式（白色字体，黑色背景，居中显示）
                ctx.fillStyle = '#000000'; // 黑色背景
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff'; // 白色文字
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(height.toString(), canvas.width / 2, canvas.height / 2);

                // 将 canvas 转为 Three.js 纹理
                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                const labelSprite = new THREE.Sprite(labelMaterial);

                // 调整标签大小和位置（在标记点右侧 0.5 单位，避免遮挡）
                labelSprite.scale.set(1, 0.5, 1); // 标签大小（宽1，高0.5）
                labelSprite.position.set(0.8, height, 0); // 在标记点右侧 0.8 单位
                poleGroup.add(labelSprite);
            }

            return poleGroup;
        }

        // 初始化场景、相机和渲染器
        const scene = new THREE.Scene();

        // 创建坐标轴辅助器（参数：坐标轴长度，默认 1，可按需调整）
        const axesHelper = new THREE.AxesHelper(1); // 这里设为 5，数值越大坐标轴越长
        scene.add(axesHelper); // 将坐标轴添加到场景

        scene.background = new THREE.Color(0x0a0a1a);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 8);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        // 1. 渲染器高清适配（关键！放在渲染器初始化后）
const dpr = window.devicePixelRatio || 1;
renderer.setPixelRatio(dpr);
renderer.setSize(window.innerWidth, window.innerHeight, false); // 第三个参数false避免二次缩放
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 软阴影更清晰，减少锯齿

        document.getElementById('container').appendChild(renderer.domElement);
        const modelFileInput = document.getElementById('modelFile'); // 文件选择器

        // 添加高度参考刻度柱
        const heightPole = createHeightReferencePole();
        scene.add(heightPole); // 添加到场景中
        
        // 添加光源
        // 1. 环境光：均匀照亮所有物体，无阴影，主要用于提亮整体
        const ambientLight = new THREE.AmbientLight(0xffffff, 1); // 颜色：白色，强度：0.6（0~1 可调）
        scene.add(ambientLight);

        // 2. 平行光：模拟太阳光，有方向性，能产生阴影（让物体更立体）
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // 颜色：白色，强度：0.8
        directionalLight.position.set(5, 10, 7); // 光源位置（调整方向，避免直射或过暗）
        scene.add(directionalLight);

        // 3. 新增补光（解决阴影处过暗）
        const fillLight = new THREE.DirectionalLight(0xffffdd, 0.9); // 暖白色补光
        fillLight.position.set(-8, 10, -5); // 与主光源反向
        scene.add(fillLight);

        // （可选）开启阴影投射（让物体产生真实阴影，更有质感）
        directionalLight.castShadow = true;
        // 优化阴影质量（可选，根据性能调整）
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;

        //控制系统和相机的绑定
        // const controls = new THREE.OrbitControls(camera, renderer.domElement);
       let controls = new THREE.OrbitControls(camera,document.getElementById('container'));
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // -------------------------- 核心补偿：触摸方向适配旋转 --------------------------
        console.log(controls);
      
       
        // --------------------------------------------------------------------------------

                    
        
       
        const sky = new Sky();
        sky.scale.setScalar(400); // 根据需要调整天空的大小
        scene.add(sky);
        const uniforms = sky.material.uniforms;
        uniforms['turbidity'].value = 10;
        uniforms['rayleigh'].value = 3;
        uniforms['mieCoefficient'].value = 0.1;
        uniforms['mieDirectionalG'].value = 0.95;
        uniforms['sunPosition'].value.set(0.3, -0.038, -0.95);
        uniforms['sunPosition'].value.set(0, 0, 0);
        // 根据需要调整太阳的位置
        const sun1 = new THREE.Vector3();
        const phi = THREE.MathUtils.degToRad(88);
        const theta = THREE.MathUtils.degToRad(180);
        sun1.setFromSphericalCoords(1, phi, theta);
        uniforms.sunPosition.value.copy(sun1);

        // 1. 创建太阳球体（可视化，带自发光）
        const sunGeometry = new THREE.SphereGeometry(1, 32, 32); // 半径1，分段数32
        const sunMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00, // 太阳黄色
        emissive: 0xffff00, // 自发光颜色
        emissiveIntensity: 50 // 发光强度（数值越大越亮）
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(50, 30, 20); // 放在场景远处（避免遮挡模型）
        scene.add(sun);
        

        // 2. 绑定强平行光（太阳光源，照亮整个场景）
        const sunLight = new THREE.DirectionalLight(0xffffff, 5.0); // 强光强度2.0
        sunLight.position.copy(sun.position); // 光源位置和太阳球体一致
        scene.add(sunLight);

        // 3. 可选：添加太阳光晕（更真实）
        const glowGeometry = new THREE.SphereGeometry(1.1, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffdd,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending // 叠加混合，光晕效果
        });
        const sunGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        sun.add(sunGlow); // 光晕跟随太阳


        // 1. 创建地板（保留原有配置）
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshLambertMaterial({
        color: 0xC39178,
        transparent: true,
        opacity: 0.8
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        scene.add(floor);

        // 2. 添加网格线（关键新增）
        const gridSize = 200; // 网格大小和地板一致
        const gridDivisions = 10; // 分割数（40=200/5，每格5单位）
        const gridHelper = new THREE.GridHelper(
        gridSize,
        gridDivisions,
        0xffffff, // 网格线颜色（白色，醒目）
        0x444444  // 辅助线颜色（深灰色，不杂乱）
        );
        gridHelper.position.y = 0.001; // 略高于地板，避免遮挡
        scene.add(gridHelper);


        // const mache = new THREE.Object3D();
        let mache = new THREE.Group();
        let loader = new GLTFLoader();


        // ------------ 核心：文件选择和加载逻辑 ------------
        modelFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; // 获取选择的文件
            if (!file) return;

            // 1. 格式校验（只允许 gltf 和 glb）
            const fileExt = file.name.split('.').pop().toLowerCase();
            if (!['gltf', 'glb'].includes(fileExt)) {
                loadStatus.style.color = '#ff4444';
                loadStatus.textContent = `错误：仅支持.glb 格式，当前文件格式为 .${fileExt}`;
                return;
            }

            // 2. 重置状态，显示加载中
            loadStatus.style.color = '#ffff00';
            loadStatus.textContent = `加载中：0%`;
            isModelLoaded = false; // 标记模型未加载完成

            // 3. 清空原有模型（如果有）
            if (mache.children.length > 0) {
                mache.remove(...mache.children); // 移除旧模型
                // 移除旧模型的包围盒线框
                if (mache.userData.boundingBoxHelper) {
                mache.remove(mache.userData.boundingBoxHelper);
                mache.userData.boundingBoxHelper = null;
                }
            }

            // 4. 加载本地文件（通过 FileReader 读取文件内容）
            const reader = new FileReader();
            reader.onload = function(loadEvent) {
                const content = loadEvent.target.result; // 文件内容（ArrayBuffer 或 DataURL）

                // 5. 用 GLTFLoader 加载文件内容
                loader.load(
                // 本地文件用 Blob URL 或 ArrayBuffer 加载
                URL.createObjectURL(file), // 生成临时 Blob URL（推荐，支持大文件）
                // 加载成功回调
                function(gltf) {
                    // 添加新模型到父容器
                    mache.add(gltf.scene);
                    mache.scale.set(1, 1, 1); // 重置缩放
                    mache.position.set(2, 0, 0); // 先设目标X/Z位置（脚底最终X/Z=2,0）

                    // 计算原始包围盒（未偏移、未缩放状态）
                    let box = new THREE.Box3().setFromObject(mache);
                    let size = new THREE.Vector3();
                    box.getSize(size);
                    let center = new THREE.Vector3();
                    box.getCenter(center);

                    // 1. 计算缩放系数：强制模型最终高度=10
                    let scale = 5 / size.y; // 按原始高度算，确保缩放后高度=10
                    mache.scale.set(scale, scale, scale); // 先缩放

                    // 2. 重新计算缩放后的包围盒，获取真实底部偏移
                    box = new THREE.Box3().setFromObject(mache);
                    box.getSize(size); // 缩放后尺寸（height=10）
                    box.getCenter(center); // 缩放后中心点

                    // 3. 计算Y偏移：让脚底贴y=0
                    let yOffset = -(center.y - size.y / 2);
                    mache.position.y += yOffset; // 叠加偏移（不覆盖原有Y=0）

                    //console.log("最终模型高度：", size.y, "脚底位置：", mache.position);

                    // 确保模型添加到场景
                    if (!scene.children.includes(mache)) {
                    scene.add(mache);
                    document.getElementById('loading').style.display = 'none';
                    }

                    // 6. 延迟校准锚点和计算高度（确保模型初始化完成）
                    setTimeout(() => {
                    // 校准锚点到脚底（排除下方空空间）
                    // const originalBottomY = getModelBottomY(mache);
                    // mache.position.y -= originalBottomY;

                    // 计算真实高度（带红色线框可视化）
                    let size1 = new THREE.Vector3();
                    new THREE.Box3().setFromObject(mache).getSize(size1);
                    const realHeight = size1.y;

                    // 7. 初始化/更新相机控制器
                    // if (!controls) {
                    //     controls = new THREE.OrbitControls(camera, renderer.domElement);
                    //     controls.enableDamping = true;
                    //     controls.dampingFactor = 0.25;
                    // }
                    // // 更新旋转中心到模型中心
                    // const targetOffset = new THREE.Vector3(0, realHeight*0.75, 0);
                    // controls.target = mache.position.clone().add(targetOffset).add(new THREE.Vector3(0, -yOffset, 0));

                    // 加载成功提示
                    loadStatus.style.color = '#00ff00';
                    loadStatus.textContent = `加载成功！模型高度：${realHeight.toFixed(2)} 单位`;
                    isModelLoaded = true; // 标记模型加载完成
                    }, 150);
                },
                // 加载进度回调
                function(xhr) {
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                    loadStatus.textContent = `加载中：${percent}%`;
                },
                // 加载失败回调
                function(error) {
                    loadStatus.style.color = '#ff4444';
                    loadStatus.textContent = `加载失败：${error.message.slice(0, 50)}...`;
                    console.error('模型加载失败：', error);
                }
                );
            };

            // 读取文件（GLTF/GLB 用 ArrayBuffer 格式读取，兼容性更好）
            reader.readAsArrayBuffer(file);
        });
    

        
        
        
        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);
        
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
             // 计算时间差：当前时间 - 上一帧时间，转换为秒（performance.now() 返回毫秒）
            const deltaTime = (performance.now() - lastTime) / 1000;
            lastTime = performance.now(); // 更新上一帧时间为当前时间
            moveModel(deltaTime); // 调用移动函数，传入时间差
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
